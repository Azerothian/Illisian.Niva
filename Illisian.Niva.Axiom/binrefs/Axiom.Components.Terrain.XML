<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Axiom.Components.Terrain</name>
    </assembly>
    <members>
        <member name="T:Axiom.Components.Terrain.TerrainLayerBlendMap">
            <summary>
            Class exposing an interface to a blend map for a given layer. 
            Each layer after the first layer in a terrain has a blend map which 
            expresses how it is alpha blended with the layers beneath. Internally, this
            blend map is packed into one channel of an RGB or RGBA texture in
            order to use the smallest number of samplers, but this class allows
            a caller to manipulate the data more easily without worrying about
            this packing. Also, the values you use to interact with the blend map are
            floating point, which gives you full precision for updating, but in fact the
            values are packed into 8-bit integers in the actual blend map.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mLayerIdx">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mChannel">
            <summary>
            RGBA
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mChannelOffset">
            <summary>
            in pixel format
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mDirtyBox">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mDirty">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerBlendMap.mData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.#ctor(Axiom.Components.Terrain.Terrain,System.Byte,Axiom.Graphics.HardwarePixelBuffer)">
            <summary>
            Constructor.
            </summary>
            <param name="parent">The parent terrain</param>
            <param name="layerIdx">The layer index (should be 1 or higher)</param>
            <param name="buf">The buffer holding the data</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.ConverWorldToUVSpace(Axiom.Math.Vector3,System.Single@,System.Single@)">
            <summary>
            Helper method - convert a point in world space to UV space based on the
            terrain settings.
            </summary>
            <param name="worldPost">World position</param>
            <param name="outX">outX, outY Pointers to variables which will be filled in with the
            local UV space value. Note they are deliberately signed Real values, because the
            point you supply may be outside of image space and may be between texels.
            The values will range from 0 to 1, top/bottom, left/right.</param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.ConvertUVToWorldSpace(System.Single,System.Single,Axiom.Math.Vector3@)">
            <summary>
            Helper method - convert a point in local space to worldspace based on the
            terrain settings.
            </summary>
            <param name="x">x,y Local position, ranging from 0 to 1, top/bottom, left/right.</param>
            <param name="y">x,y Local position, ranging from 0 to 1, top/bottom, left/right.</param>
            <param name="worldPos">Vector will be filled in with the world space value</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.ConvertUVToImageSpace(System.Single,System.Single,System.Int32@,System.Int32@)">
            <summary>
            Convert local space values (0,1) to image space (0, imageSize).
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outX"></param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.ConvertImageToUVSpace(System.Int32,System.Int32,System.Single@,System.Single@)">
            <summary>
            Convert image space (0, imageSize) to local space values (0,1).
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outX"></param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.ConvertImageToTerrainSpace(System.Int32,System.Int32,System.Single@,System.Single@)">
            <summary>
             Convert image space (0, imageSize) to terrain space values (0,1).
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outX"></param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.ConvertTerrainToImageSpace(System.Single,System.Single,System.Int32@,System.Int32@)">
            <summary>
            Convert terrain space values (0,1) to image space (0, imageSize).
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outX"></param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.GetBlendValue(System.Int32,System.Int32)">
            <summary>
            Get a single value of blend information, in image space.
            </summary>
            <param name="x">x,y Coordinates of the point of data to get, in image space (top down)</param>
            <param name="y"></param>
            <returns>The blend data</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.SetBlendValue(System.Int32,System.Int32,System.Single)">
            <summary>
            Set a single value of blend information (0 = transparent, 255 = solid)
            </summary>
            <param name="x">x,y Coordinates of the point of data to get, in image space (top down)</param>
            <param name="y"></param>
            <param name="val">The blend value to set (0..1)</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.Dirty">
            <summary>
            Indicate that all of the blend data is dirty and needs updating.
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.DirtyRect(Axiom.Core.Rectangle)">
            <summary>
            Indicate that a portion of the blend data is dirty and needs updating.
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.Blit(Axiom.Media.PixelBox@,Axiom.Media.BasicBox)">
            <summary>
            Blits a set of values into a region on the blend map. 
            </summary>
            <param name="src">PixelBox containing the source pixels and format </param>
            <param name="dstBox">describing the destination region in this map</param>
            <remarks>
            The source and destination regions dimensions don't have to match, in which
            case scaling is done. 
            </remarks>
            <note>
            You can call this method in a background thread if you want.
            You still need to call update() to commit the changes to the GPU. 
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.LoadImage(Axiom.Media.Image)">
            <summary>
            Load an image into this blend layer. 
            </summary>
            <param name="img"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.LoadImage(System.IO.Stream,System.String)">
            <summary>
            Load an image into this blend layer. 
            </summary>
            <param name="stream"></param>
            <param name="extension"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.LoadImage(System.IO.Stream)">
            <summary>
            Load an image into this blend layer. 
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.LoadImage(System.String,System.String)">
            <summary>
            Load an image into this blend layer. 
            </summary>
            <param name="fileName"></param>
            <param name="groupName"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.Update">
            <summary>
            Publish any changes you made to the blend data back to the blend map. 
            </summary>
            <note>
            Can only be called in the main render thread.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.Download">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerBlendMap.GetBitShifts(Axiom.Media.PixelFormat,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="fmt"></param>
            <param name="rgba"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainLayerBlendMap.Parent">
            <summary>
            Get's the parent terrain.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainLayerBlendMap.LayerIndex">
            <summary>
            Get's the index of the layer this is targetting
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainLayerBlendMap.BlendPointer">
            <summary>
            Get a float array of the whole blend data. 
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGeneratorA">
            <summary>
            A TerrainMaterialGenerator which can cope with normal mapped, specular mapped
            terrain.
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGenerator">
            <summary>
            Class that provides functionality to generate materials for use with a terrain.
            </summary>
            <remarks>
            Terrains are composed of one or more layers of texture information, and
            require that a material is generated to render them. There are various approaches
            to rendering the terrain, which may vary due to:
            <ul><li>Hardware support (static)</li>
            <li>Texture instances assigned to a particular terrain (dynamic in an editor)</li>
            <li>User selection (e.g. changing to a cheaper option in order to increase performance, 
            or in order to test how the material might look on other hardware (dynamic)</li>
            </ul>
            Subclasses of this class are responsible for responding to these factors and
            to generate a terrain material. 
            @par
            In order to cope with both hardware support and user selection, the generator
            must expose a number of named 'profiles'. These profiles should function on
            a known range of hardware, and be graded by quality. At runtime, the user 
            should be able to select the profile they wish to use (provided hardware
            support is available). 
            </remarks>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mProfiles">
            <summary>
            List of profiles - NB should be ordered in descending complexity
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mActiveProfile">
            <summary>
            the currently active profile
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mChangeCounter">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mLayerDecl">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mDebugLevel">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mCompositeMapSM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mCompositeMapCam">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mCompositeMapRTT">
            <summary>
            deliberately holding this by raw pointer to avoid shutdown issues
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mCompositeMapPlane">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.mCompositeMapLight">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.SetActiveProfile(System.String)">
            <summary>
            Set the active profile by name.
            </summary>
            <param name="name">name of the profile</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.CanGenerateUsingDeclaration(Axiom.Components.Terrain.TerrainLayerDeclaration)">
            <summary>
            Whether this generator can generate a material for a given declaration. 
            By default this only returns true if the declaration is equal to the 
            standard one returned from getLayerDeclaration, but if a subclass wants
            to be flexible to generate materials for other declarations too, it 
            can specify here. 
            </summary>
            <param name="decl"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.RequestOption(Axiom.Components.Terrain.Terrain)">
            <summary>
            Triggers the generator to request the options that it needs.
            </summary>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Generate(Axiom.Components.Terrain.Terrain)">
            <summary>
            Generate a material for the given terrain using the active profile.
            </summary>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.GenerateForCompositeMap(Axiom.Components.Terrain.Terrain)">
            <summary>
            Generate a material for the given composite map of the terrain using the active profile.
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.MarkChanged">
            <summary>
            Internal method - indicates that a change has been made that would require material regeneration
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.GetMaxLayers(Axiom.Components.Terrain.Terrain)">
            <summary>
            Get the maximum number of layers supported with the given terrain. 
            </summary>
            <value>
            When you change the options on the terrain, this value can change.
            </value>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.UpdateCompositeMap(Axiom.Components.Terrain.Terrain,Axiom.Core.Rectangle)">
            <summary>
            Update the composite map for a terrain.
            The composite map for a terrain must match what the terrain should look like
            at distance. This method will only be called in the render thread so the
            generator is free to render into a texture to support this, so long as 
            the results are blitted into the Terrain's own composite map afterwards.
            </summary>
            <param name="terrain"></param>
            <param name="rect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.UpdateParams(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain)">
            <summary>
            Update parameters for the given terrain using the active profile.
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.UpdateParamsForCompositeMap(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain)">
            <summary>
            Update parameters for the given terrain using the active profile.
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.RenderCompositeMap(System.Int32,Axiom.Core.Rectangle,Axiom.Graphics.Material,Axiom.Core.Texture)">
            <summary>
            Helper method to render a composite map.
            </summary>
            <param name="size"> The requested composite map size</param>
            <param name="rect"> The region of the composite map to update, in image space</param>
            <param name="mat">The material to use to render the map</param>
            <param name="destCompositeMap"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.Profiles">
            <summary>
            List of profiles - NB should be ordered in descending complexity
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.ActiveProfile">
            <summary>
            Get's or Set's the active profile
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.ChangeCount">
            <summary>
            Returns the number of times the generator has undergone a change which 
            would require materials to be regenerated.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.LayerDeclaration">
            <summary>
            Get the layer declaration that this material generator operates with.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.DebugLevel">
            <summary>
            Get's or set's the debug level of the material. 
            </summary>
            <remarks>
            Sets the level of debug display for this material.
            What this debug level means is entirely depdendent on the generator, 
            the only constant is that 0 means 'no debug' and non-zero means 
            'some level of debugging', with any graduations in non-zero values
            being generator-specific.
            </remarks>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.CompositeMapRTT">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile">
            <summary>
            Inner class which should also be subclassed to provide profile-specific 
            material generation.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.mName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.mDesc">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.#ctor(Axiom.Components.Terrain.TerrainMaterialGenerator,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="description"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.#ctor(Axiom.Components.Terrain.TerrainMaterialGenerator.Profile)">
            <summary>
            
            </summary>
            <param name="profile"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.Generate(Axiom.Components.Terrain.Terrain)">
            <summary>
            Generate / reuse a material for the terrain
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.GenerateForCompositeMap(Axiom.Components.Terrain.Terrain)">
            <summary>
            Generate / reuse a material for the terrain
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.GetMaxLayers(Axiom.Components.Terrain.Terrain)">
            <summary>
            Get's the number of layers supported
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.UpdateParams(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain)">
            <summary>
            Update params for a terrain
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.UpdateParamsForCompositeMap(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain)">
            <summary>
            Update params for a terrain
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.RequestOption(Axiom.Components.Terrain.Terrain)">
            <summary>
            Request the options needed from the terrain
            </summary>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.UpdateCompositeMap(Axiom.Components.Terrain.Terrain,Axiom.Core.Rectangle)">
            <summary>
            Update the composite map for a terrain
            </summary>
            <param name="terrain"></param>
            <param name="rect"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.Parent">
            <summary>
            Get's the generator which owns this profile
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.Name">
            <summary>
            Get's the name of this profile
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGenerator.Profile.Description">
            <summary>
            Get's the description of this profile
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile">
            <summary>
            Shader model 2 profile target.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mShaderGen">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mLayerNormalMappingEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mLayerParallaxMappingEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mLayerSpecularMappingEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mGlobalColorMapEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mLightMapEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.mCompositeMapEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.#ctor(Axiom.Components.Terrain.TerrainMaterialGenerator,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="description"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.AddTechnique(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.Generate(Axiom.Components.Terrain.Terrain)">
            <summary>
            
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.GenerateForCompositeMap(Axiom.Components.Terrain.Terrain)">
            <summary>
            
            </summary>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.UpdateParams(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.UpdateParamsForCompositeMap(Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain)">
            <summary>
            
            </summary>
            <param name="mat"></param>
            <param name="terrain"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.RequestOption(Axiom.Components.Terrain.Terrain)">
            <summary>
            
            </summary>
            <param name="terrain"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.IsLayerNormalMappingEnabled">
            <summary>
             Whether to support normal mapping per layer in the shader (default true).
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.IsLayerParallaxMappingEnabled">
            <summary>
            Whether to support parallax mapping per layer in the shader (default true).
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.IsLayerSpecularMappingEnabled">
            <summary>
            Whether to support specular mapping per layer in the shader (default true).
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.IsGlobalColorMapEnabled">
            <summary>
            Whether to support a global colour map over the terrain in the shader,
            if it's present (default true).
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.IsLightMapEnabled">
            <summary>
            Whether to support a light map over the terrain in the shader,
            if it's present (default true).
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.IsCompositeMapEnabled">
            <summary>
            Whether to use the composite map to provide a lower LOD technique
            in the distance (default true).
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper">
            <summary>
            Interface definition for helper class to generate shaders
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateVertexProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateFragmentProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.UpdateParams(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Graphics.Material,Axiom.Components.Terrain.Terrain,System.Boolean)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="mat"></param>
            <param name="terrain"></param>
            <param name="compositeMap"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GetVertexProgramName(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GetFragmentProgramName(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.CreateVertexProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.CreateFragmentProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateVertexProgramSource(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateFragmetProgramSource(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateVpHeader(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateFpHeader(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateVpLayer(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.UInt32,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateFpLayer(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.UInt32,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateFpFooter(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GenerateVpFooter(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.DefaultVpParams(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,Axiom.Graphics.HighLevelGpuProgram)">
            <summary>
            /
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="prog"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.DefaultFpParams(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,Axiom.Graphics.HighLevelGpuProgram)">
            <summary>
            /
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="prog"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.UpdateVpParams(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,Axiom.Graphics.GpuProgramParameters)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="gpuparams"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.UpdateFpParams(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,Axiom.Graphics.GpuProgramParameters)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="gpuparams"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelper.GetChannel(System.UInt32)">
            <summary>
            
            </summary>
            <param name="idx"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.CreateVertexProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.CreateFragmentProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.GenerateVpHeader(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.GenerateFpHeader(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.GenerateVpLayer(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.UInt32,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="layer"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.GenerateFpLayer(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.UInt32,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="layer"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.GenerateVpFooter(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperCG.GenerateFpFooter(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperHLSL">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperHLSL.CreateVertexProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperHLSL.CreateFragmentProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.CreateVertexProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.CreateFragmentProgram(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.GenerateVpHeader(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.GenerateFpFooter(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.GenerateFpHeader(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.GenerateVpLayer(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.UInt32,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="layer"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.GenerateFpLayer(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.UInt32,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="layer"></param>
            <param name="source"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.ShaderHelperGLSL.GenerateVpFooter(Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile,Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainMaterialGeneratorA.SM2Profile.TechniqueType,System.String@)">
            <summary>
            
            </summary>
            <param name="prof"></param>
            <param name="terrain"></param>
            <param name="tt"></param>
            <param name="source"></param>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainSlotDefinition">
            <summary>
            Definition of how to populate a 'slot' in the terrain group.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainSlotDefinition.FileName">
            <summary>
            Filename, if this is to be loaded from a file
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainSlotDefinition.ImportData">
            <summary>
            Import data, if this is to be defined based on importing
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainSlotDefinition.UseImportData">
            <summary>
            Set to use import data 
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainSlotDefinition.UseFilename">
            <summary>
            Set to use file name
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainSlotDefinition.FreeImportData">
            <summary>
            Destroy temp import resources
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainSlotDefinition.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainSlot">
            <summary>
            Slot for a terrain instance, together with its definition.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainSlot.X">
            <summary>
            The coordinates of the terrain slot relative to the centre slot (signed).
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainSlot.Y">
            <summary>
            The coordinates of the terrain slot relative to the centre slot (signed).
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainSlot.Instance">
            <summary>
            Actual terrain instance
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainSlot.Def">
            <summary>
            Definition used to load the terrain
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainSlot.#ctor(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainSlot.FreeInstance">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.RayResult">
            <summary>
            Result from a terrain ray intersection with the terrain group. 
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.RayResult.Hit">
            <summary>
            Whether an intersection occurred
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.RayResult.Terrain">
            <summary>
            Which terrain instance was hit, if any
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.RayResult.Position">
            <summary>
            Position at which the intersection occurred
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.RayResult.#ctor(System.Boolean,Axiom.Components.Terrain.Terrain,Axiom.Math.Vector3)">
            <summary>
            Constructor.
            </summary>
            <param name="hit">Whether an intersection occurred</param>
            <param name="terrain">Which terrain instance was hit, if any</param>
            <param name="pos">Position at which the intersection occurred</param>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainGroup">
            <summary>
            Helper class to assist you in managing multiple terrain instances
            that are connected to each other.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup.ChunkID">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup.ChunkVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._sceneManager">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._alignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._terrainSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._terrainWorldSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._defaultImportData">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._origin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._terrainSlots">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._workQueueChannel">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._filenamePrefix">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._filenameExtension">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGroup._resourceGroup">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.#ctor(Axiom.Core.SceneManager)">
            <summary>
            Alternate constructor.
            *important*
            You can ONLY use this constructor if you subsequently call loadGroupDefinition
            to populate the rest.
            *important*
            </summary>
            <param name="sm">The SceneManager which will parent the terrain instances.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.#ctor(Axiom.Core.SceneManager,Axiom.Components.Terrain.Alignment,System.UInt16,System.Single)">
            <summary>
            Constructor.
            </summary>
            <param name="sm">The SceneManager which will parent the terrain instances.</param>
            <param name="align">The alignment that all terrain instances will use</param>
            <param name="terrainSize">The size of each terrain down one edge in vertices (2^n+1)</param>
            <param name="terrainWorldSize">The world size of each terrain instance</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.SetFilenamConvention(System.String,System.String)">
            <summary>
            Set the naming convention for file names in this terrain group.
            </summary>
            <param name="prefix"></param>
            <param name="extension"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64)">
            <summary>
            Define a 'slot' in the terrain grid - in this case to be loaded from 
            a generated file name.
            </summary>
            <param name="x"> The coordinates of the terrain slot relative to the centre slot (signed).</param>
            <param name="y"> The coordinates of the terrain slot relative to the centre slot (signed).</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,System.Single)">
            <summary>
            Define a 'slot' in the terrain grid - in this case a flat terrain.
            </summary>
            <param name="x">The coordinates of the terrain slot relative to the centre slot (signed).</param>
            <param name="y">The coordinates of the terrain slot relative to the centre slot (signed).</param>
            <param name="constantHeight">
            The constant, uniform height that you want the terrain
            to start at
            </param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,Axiom.Components.Terrain.ImportData)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="importData"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,Axiom.Media.Image)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="image"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,Axiom.Media.Image,System.Collections.Generic.List{Axiom.Components.Terrain.LayerInstance})">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="image"></param>
            <param name="layers"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,System.Single[])">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="image"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,System.Single[],System.Collections.Generic.List{Axiom.Components.Terrain.LayerInstance})">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="image"></param>
            <param name="layers"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.DefineTerrain(System.Int64,System.Int64,System.String)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="filename"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.LoadAllTerrains">
            <summary>
            Load any terrain instances that have been defined but not loaded yet.
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.LoadAllTerrains(System.Boolean)">
            <summary>
            Load any terrain instances that have been defined but not loaded yet.
            </summary>
            <param name="synchronous"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.LoadTerrain(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.LoadTerrain(System.Int64,System.Int64,System.Boolean)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="synchronous"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.UnloadTerrain(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.RemoveTerrain(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.RemoveAllTerrains">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.SaveAllTerrains(System.Boolean)">
            <summary>
            
            </summary>
            <param name="onlyIfModified"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.SaveAllTerrains(System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="onlyIfModified"></param>
            <param name="replaceManualFilenames"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetTerrainDefinition(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetTerrain(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.FreeTemporaryResources">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.Update">
            <summary>
            Trigger the update process for all terrain instances.
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.Update(System.Boolean)">
            <summary>
            Trigger the update process for all terrain instances.
            </summary>
            <param name="synchronous"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.UpdateGeometry">
            <summary>
            Performs an update on all terrain geometry.
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.UpdateDerivedData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.UpdateDerivedData(System.Boolean)">
            <summary>
            
            </summary>
            <param name="synchronous"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.UpdateDerivedData(System.Boolean,System.Byte)">
            <summary>
            
            </summary>
            <param name="synchronous"></param>
            <param name="typeMask"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetHeightAtWorldPosition(System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetHeightAtWorldPosition(System.Single,System.Single,System.Single,Axiom.Components.Terrain.Terrain@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetHeightAtWorldPosition(Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetHeightAtWorldPosition(Axiom.Math.Vector3,Axiom.Components.Terrain.Terrain@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="terrain"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.RayIntersects(Axiom.Math.Ray)">
            <summary>
            
            </summary>
            <param name="ray"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.RayIntersects(Axiom.Math.Ray,System.Single)">
            <summary>
            
            </summary>
            <param name="ray"></param>
            <param name="distanceLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.Swap(System.Single,System.Single)">
            <summary>
            Swaps to objects. be sure they have the same type
            </summary>
            <param name="oba"></param>
            <param name="obb"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.BoxIntersects(Axiom.Math.AxisAlignedBox,System.Collections.Generic.List{Axiom.Components.Terrain.Terrain}@)">
            <summary>
            
            </summary>
            <param name="box"></param>
            <param name="terrainList"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.SphereIntersects(Axiom.Math.Sphere,System.Collections.Generic.List{Axiom.Components.Terrain.Terrain}@)">
            <summary>
            /
            </summary>
            <param name="sphere"></param>
            <param name="terrainList"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.ConvertWorldPositionToTerrainSlot(Axiom.Math.Vector3,System.Int64@,System.Int64@)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.ConvertTerrainSlotToWorldPosition(System.Int64,System.Int64,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="position"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.PackIndex(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.UnpackIndex(System.UInt32,System.Int64@,System.Int64@)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GenerateFilename(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.SaveGroupDefinition(System.String)">
            <summary>
            
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.SaveGroupDefinition(Axiom.Serialization.StreamSerializer@)">
            <summary>
            
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.LoadGroupDefinition(System.String)">
            <summary>
            
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.LoadGroupDefinition(Axiom.Serialization.StreamSerializer@)">
            <summary>
            
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetTerrainSlotPosition(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetTerrainSlot(System.Int64,System.Int64,System.Boolean)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="createIfMissing"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.GetTerrainSlot(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainGroup.ConnectNeighbour(Axiom.Components.Terrain.TerrainSlot,System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="slot"></param>
            <param name="offsetx"></param>
            <param name="offsety"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.TerrainSlots">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.DefaultImportSettings">
            <summary>
            Get's a shared structure which will provide the base settings for
            all terrains created via this group.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.Origin">
            <summary>
            Define the centre position of the grid of terrain.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.Alignment">
            <summary>
            Get's the alignment of the grid of terrain (cannot be modified after construction).
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.TerrainWorldSize">
            <summary>
            Retrieve the world size of each terrain instance
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.TerrainSize">
            <summary>
            Get's the size of each terrain instance in number of vertices down one side
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.SceneManager">
            <summary>
            Get's the SceneManager being used for this group.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.FilenamePrefix">
            <summary>
            <see cref="M:Axiom.Components.Terrain.TerrainGroup.SetFilenamConvention(System.String,System.String)"/>
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.FilenameExtension">
            <summary>
            <see cref="M:Axiom.Components.Terrain.TerrainGroup.SetFilenamConvention(System.String,System.String)"/>
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.ResourceGroup">
            <summary>
            Get's or Set's the resource group in which files will be located.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGroup.IsDerivedDataUpdateInProgress">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.mSkirtSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msLightMapDir">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msCastsShadows">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msMaxPixelError">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msRenderQueueGroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msUseRayBoxDistanceCalculation">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msDefaultMaterialGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msLayerBlendMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msDefaultLayerTextureWorldSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msDefaultGlobalColourMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msLightmapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msCompositeMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msCompositeMapAmbient">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msCompositeMapDiffuse">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msCompositeMapDistance">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msVisibililityFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainGlobalOptions.msQueryFlags">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.QueryFlags">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.VisibilityFlags">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.LightMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.SkirtSize">
            <summary>
            Static method - the default size of 'skirts' used to hide terrain cracks
            (default 10)
            </summary>
            <remarks>
            Changing this value only applies to Terrain instances loaded / reloaded afterwards.
            </remarks>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.LightMapDirection">
            <summary>
            Get' or set's the shadow map light direction to use (world space)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.CastsDynamicShadows">
            <summary>
            Whether the terrain will be able to cast shadows (texture shadows
            only are supported, and you must be using depth shadow maps).
            
            This value can be set dynamically, and affects all existing terrains.
            It defaults to false. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.CompositeMapAmbient">
            <summary>
            Get's or set's  the composite map ambient light to use 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.CompositeMapDiffuse">
            <summary>
            Get's or set's the composite map iffuse light to use 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.MaxPixelError">
            <summary>
            Get' or Set's the maximum screen pixel error that should be allowed when rendering.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.RenderQueueGroupID">
            <summary>
            Get's or set's the render queue group that this terrain will be rendered into
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.IsUseRayBoxDistanceCalculation">
            <summary>
            Get's - whether or not to use an accurate calculation of camera distance
            from a terrain tile (ray / AABB intersection) or whether to use the
            simpler distance from the tile centre.
            
            Set's - whether to use an accurate ray / box intersection to determine
            distance from a terrain tile, or whether to use the simple distance
            from the tile centre.
            Using ray/box intersection will result in higher detail terrain because 
            the LOD calculation is more conservative, assuming the 'worst case scenario' 
            of a large height difference at the edge of a tile. This is guaranteed to give you at least
            the max pixel error or better, but will often give you more detail than
            you need. Not using the ray/box method is cheaper but will only use
            the max pixel error as a guide, the actual error will vary above and
            below that. The default is not to use the ray/box approach.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.DefaultMaterialGenerator">
            <summary>
             Get's or set's the default material generator.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.LayerBlendMapSize">
            <summary>
            Set's  - the default size of blend maps for a new terrain.
            This is the resolution of each blending layer for a new terrain. 
            Once created, this information will be stored with the terrain.
            
            Get's - the default size of the blend maps for a new terrain. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.DefaultLayerTextureWorldSize">
            <summary>
            Get's or Set's the default world size for a layer 'splat' texture to cover. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.DefaultGlobalColorMapSize">
            <summary>
            Get's - the default size of the terrain global colour map for a new terrain.
            Set's -the default size of the terrain global colour map for a new terrain. 
            Once created, this information will be stored with the terrain. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.LightsMapCount">
            <summary>
            Get' or set's the default size of the lightmaps for a new terrain. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.CompositeMapSize">
            <summary>
            Get's or set's the default size of the composite maps for a new terrain. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainGlobalOptions.CompositeMapDistance">
            <summary>
             Get's or set's the distance at which to start using a composite map if present
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainLayerSamplerSemantic">
            <summary>
            Enumeration of types of data that can be read from textures that are
            specific to a given layer. Notice that global texture information 
            such as shadows and terrain normals are not represented
            here because they are not a per-layer attribute, and blending
            is stored in packed texture structures which are stored separately.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerSemantic.Albedo">
            <summary>
             Albedo colour (diffuse reflectance colour)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerSemantic.Normal">
            <summary>
            Tangent-space normal information from a detail texture
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerSemantic.Height">
            <summary>
            Height information for the detail texture
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerSemantic.Specular">
            <summary>
            Specular reflectance
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainLayerSamplerElement">
            <summary>
            Information about one element of a sampler / texture within a layer.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerElement.Source">
            <summary>
            The source sampler index of this element relative to LayerDeclaration's list
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerElement.Semantic">
            <summary>
            The semantic this element represents
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerElement.ElementStart">
            <summary>
            The colour element at which this element starts
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSamplerElement.ElementCount">
            <summary>
            The number of colour elements this semantic uses (usually standard per semantic)
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerSamplerElement.op_Equality(Axiom.Components.Terrain.TerrainLayerSamplerElement,Axiom.Components.Terrain.TerrainLayerSamplerElement)">
            <summary>
            
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerSamplerElement.op_Inequality(Axiom.Components.Terrain.TerrainLayerSamplerElement,Axiom.Components.Terrain.TerrainLayerSamplerElement)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerSamplerElement.#ctor(System.Byte,Axiom.Components.Terrain.TerrainLayerSamplerSemantic,System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="src"></param>
            <param name="sem"></param>
            <param name="elemStart"></param>
            <param name="elemCount"></param>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainLayerSampler">
            <summary>
            Description of a sampler that will be used with each layer.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSampler.Alias">
            <summary>
            A descriptive name that is merely used to assist in recognition
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerSampler.Format">
            <summary>
            The format required of this texture
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainLayerSampler.#ctor(System.String,Axiom.Media.PixelFormat)">
            <summary>
            
            </summary>
            <param name="aliasName"></param>
            <param name="format"></param>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainLayerDeclaration">
            <summary>
            The definition of the information each layer will contain in this terrain.
            All layers must contain the same structure of information, although the
            input textures can be different per layer instance. 
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerDeclaration.Samplers">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainLayerDeclaration.Elements">
            <summary>
            
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.DerivedDataRequest">
            <summary>
            A data holder for communicating with the background derived data update
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.DerivedDataResponse">
            <summary>
             A data holder for communicating with the background derived data update
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.LayerInstance">
            <summary>
            An instance of a layer, with specific texture names
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LayerInstance.WorldSize">
            <summary>
            The world size of the texture to be applied in this layer
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LayerInstance.TextureNames">
            <summary>
            List of texture names to import; must match with TerrainLayerDeclaration
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.Alignment">
            <summary>
             The alignment of the terrain
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Alignment.Align_X_Z">
            <summary>
            Terrain is in the X/Z plane
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Alignment.Align_X_Y">
            <summary>
            Terrain is in the X/Y plane
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Alignment.Align_Y_Z">
            <summary>
            Terrain is in the Y/Z plane
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.Space">
            <summary>
            Enumeration of relative spaces that you might want to use to address the terrain
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Space.WorldSpace">
            <summary>
             Simple global world space, axes and positions are all in world space
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Space.LocalSpace">
            <summary>
            As world space, but positions are relative to the terrain world position
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Components.Terrain.Space.TerrainSpace" -->
        <!-- Badly formed XML comment ignored for member "F:Axiom.Components.Terrain.Space.PointSpace" -->
        <member name="T:Axiom.Components.Terrain.NeighbourIndex">
            <summary>
            Neighbour index enumeration - indexed anticlockwise from East like angles
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.ImportData">
            <summary>
            Structure encapsulating import data that you may use to bootstrap 
            the terrain without loading from a native data stream. 
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.TerrainAlign">
            <summary>
            The alignment of the terrain
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.TerrainSize">
            <summary>
            Terrain size (along one edge) in vertices; must be 2^n+1
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Axiom.Components.Terrain.ImportData.MaxBatchSize" -->
        <member name="F:Axiom.Components.Terrain.ImportData.MinBatchSize">
            <summary>
            Minimum batch size (along one edge) in vertices; must be 2^n+1.
            <remarks>
            The terrain will be divided into tiles, and this is the minimum
            size of one tile in vertices (at any LOD). Adjacent tiles will be
            collected together into one batch to drop LOD levels once they are individually at this minimum,
            so setting this value higher means greater batching at the expense
            of making adjacent tiles use a common LOD.
            Once the entire terrain is collected together into one batch this 
            effectively sets the minimum LOD.
            </remarks>
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.Pos">
            <summary>
            Position of the terrain.
            <remarks>
            Represents the position of the centre of the terrain.
            </remarks>
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.WorldSize">
            <summary>
             The world size of the terrain.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.InputImage">
            <summary>
            Optional heightmap providing the initial heights for the terrain.
            <remarks>
            If supplied, should ideally be terrainSize * terrainSize, but if
            it isn't it will be resized.
            </remarks>
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.InputFloat">
            <summary>
            Optional list of terrainSize * terrainSize floats defining the terrain. 
            The list of floats wil be interpreted such that the first row
            in the array equates to the bottom row of vertices. 
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.InputScale">
            <summary>
            How to scale the input values provided (if any)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.InputBias">
            <summary>
            How to bias the input values provided (if any)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.LayerDeclaration">
            <summary>
            Definition of the contents of each layer (required).
            Most likely,  you will pull a declaration from a TerrainMaterialGenerator
            of your choice.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.LayerList">
            <summary>
            List of layer structures, one for each layer required.
            Can be empty or underfilled if required, list will be padded with
            blank textures.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.DeleteInputData">
            <summary>
            Definition of the contents of each layer (required).
            Most likely,  you will pull a declaration from a TerrainMaterialGenerator
            of your choice.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.ImportData.ConstantHeight">
            <summary>
             If neither inputImage or inputFloat are supplied, the constant
              height at which the initial terrain should be created (flat).
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.ImportData.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.Terrain">
            <summary>
            The main containing class for a chunk of terrain.
            </summary>
            <remarks>
            	Terrain can be edited and stored.
            The data format for this in a file is:<br/>
            <b>TerrainData (Identifier 'TERR')</b>\n
            [Version 1]
            <table>
            <tr>
            	<td><b>Name</b></td>
            	<td><b>Type</b></td>
            	<td><b>Description</b></td>
            </tr>
            <tr>
            	<td>Terrain orientation</td>
            	<td>uint8</td>
            	<td>The orientation of the terrain; XZ = 0, XY = 1, YZ = 2</td>
            </tr>
            <tr>
            	<td>Terrain size</td>
            	<td>uint16</td>
            	<td>The number of vertices along one side of the terrain</td>
            </tr>
            <tr>
            	<td>Terrain world size</td>
            	<td>Real</td>
            	<td>The world size of one side of the terrain</td>
            </tr>
            <tr>
            	<td>Max batch size</td>
            	<td>uint16</td>
            	<td>The maximum batch size in vertices along one side</td>
            </tr>
            <tr>
            	<td>Min batch size</td>
            	<td>uint16</td>
            	<td>The minimum batch size in vertices along one side</td>
            </tr>
            <tr>
            	<td>Position</td>
            	<td>Vector3</td>
            	<td>The location of the centre of the terrain</td>
            </tr>
            <tr>
            	<td>Height data</td>
            	<td>float[size*size]</td>
            	<td>List of floating point heights</td>
            </tr>
            <tr>
            	<td>LayerDeclaration</td>
            	<td>LayerDeclaration*</td>
            	<td>The layer declaration for this terrain (see below)</td>
            </tr>
            <tr>
            	<td>Layer count</td>
            	<td>uint8</td>
            	<td>The number of layers in this terrain</td>
            </tr>
            <tr>
            	<td>LayerInstance list</td>
            	<td>LayerInstance*</td>
            	<td>A number of LayerInstance definitions based on layer count (see below)</td>
            </tr>
            <tr>
            	<td>Layer blend map size</td>
            	<td>uint16</td>
            	<td>The size of the layer blend maps as stored in this file</td>
            </tr>
            <tr>
            	<td>Packed blend texture data</td>
            	<td>uint8*</td>
            	<td>layerCount-1 sets of blend texture data interleaved as either RGB or RGBA 
            		depending on layer count</td>
            </tr>
            <tr>
            	<td>Optional derived map data</td>
            	<td>TerrainDerivedMap list</td>
            	<td>0 or more sets of map data derived from the original terrain</td>
            </tr>
            </table>
            <b>TerrainLayerDeclaration (Identifier 'TDCL')</b>\n
            [Version 1]
            <table>
            <tr>
            	<td><b>Name</b></td>
            	<td><b>Type</b></td>
            	<td><b>Description</b></td>
            </tr>
            <tr>
            	<td><b>TerrainLayerSampler Count</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Number of samplers in this declaration</b></td>
            </tr>
            <tr>
            	<td><b>TerrainLayerSampler List</b></td>
            	<td><b>TerrainLayerSampler*</b></td>
            	<td><b>List of TerrainLayerSampler structures</b></td>
            </tr>
            <tr>
            	<td><b>Sampler Element Count</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Number of sampler elements in this declaration</b></td>
            </tr>
            <tr>
            	<td><b>TerrainLayerSamplerElement List</b></td>
            	<td><b>TerrainLayerSamplerElement*</b></td>
            	<td><b>List of TerrainLayerSamplerElement structures</b></td>
            </tr>
            </table>
            <b>TerrainLayerSampler (Identifier 'TSAM')</b>\n
            [Version 1]
            <table>
            <tr>
            	<td><b>Name</b></td>
            	<td><b>Type</b></td>
            	<td><b>Description</b></td>
            </tr>
            <tr>
            	<td><b>Alias</b></td>
            	<td><b>String</b></td>
            	<td><b>Alias name of this sampler</b></td>
            </tr>
            <tr>
            	<td><b>Format</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Desired pixel format</b></td>
            </tr>
            </table>
            <b>TerrainLayerSamplerElement (Identifier 'TSEL')</b>\n
            [Version 1]
            <table>
            <tr>
            	<td><b>Name</b></td>
            	<td><b>Type</b></td>
            	<td><b>Description</b></td>
            </tr>
            <tr>
            	<td><b>Source</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Sampler source index</b></td>
            </tr>
            <tr>
            	<td><b>Semantic</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Semantic interpretation of this element</b></td>
            </tr>
            <tr>
            	<td><b>Element start</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Start of this element in the sampler</b></td>
            </tr>
            <tr>
            	<td><b>Element count</b></td>
            	<td><b>uint8</b></td>
            	<td><b>Number of elements in the sampler used by this entry</b></td>
            </tr>
            </table>
            <b>LayerInstance (Identifier 'TLIN')</b>\n
            [Version 1]
            <table>
            <tr>
            	<td><b>Name</b></td>
            	<td><b>Type</b></td>
            	<td><b>Description</b></td>
            </tr>
            <tr>
            	<td><b>World size</b></td>
            	<td><b>Real</b></td>
            	<td><b>The world size of this layer (determines UV scaling)</b></td>
            </tr>
            <tr>
            	<td><b>Texture list</b></td>
            	<td><b>String*</b></td>
            	<td><b>List of texture names corresponding to the number of samplers in the layer declaration</b></td>
            </tr>
            </table>
            <b>TerrainDerivedData (Identifier 'TDDA')</b>\n
            [Version 1]
            <table>
            <tr>
            	<td><b>Name</b></td>
            	<td><b>Type</b></td>
            	<td><b>Description</b></td>
            </tr>
            <tr>
            	<td><b>Derived data type name</b></td>
            	<td><b>String</b></td>
            	<td><b>Name of the derived data type ('normalmap', 'lightmap', 'colourmap', 'compositemap')</b></td>
            </tr>
            <tr>
            	<td><b>Size</b></td>
            	<td><b>uint16</b></td>
            	<td><b>Size of the data along one edge</b></td>
            </tr>
            <tr>
            	<td><b>Data</b></td>
            	<td><b>varies based on type</b></td>
            	<td><b>The data</b></td>
            </tr>
            </table>
            </remarks>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mResourceGroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mSceneMgr">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mRootNode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mHeightData">
            <summary>
            /// The height data (world coords relative to mPos)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDeltaData">
            <summary>
            /// The delta information defining how a vertex moves before it is removed at a lower LOD
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mAlign">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mWorldSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaxBatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMinBatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mPos">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mQuadTree">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mNumLodLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mNumLodLevelsPerLeafNode">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mTreeDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mBase">
            <summary>
            Base position in world space, relative to mPos
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mScale">
            <summary>
            Relationship between one point on the terrain and world size
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLayerDecl">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLayerUVMultiplier">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mSkirtSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mRenderQueueGroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDirtyGeometryRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDirtyDerivedDataRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDerivedDataUpdateInProgress">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDerivedUpdatePendingMask">
            <summary>
            if another update is requested while one is already running
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaterialName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaterial">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaterialGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaterialGenerationCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaterialDirty">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mMaterialParamsDirty">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLayerBlendMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLayerBlendSizeActual">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCpuBlendMapStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mBlendTextureList">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLayerBlendMapList">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mGlobalColorMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mGlobalColorMapEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mColorMap">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCpuColorMapStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLightmapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLightmapSizeActual">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLightMap">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCpuLightmapStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapSizeActual">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMap">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCpuCompositeMapStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapDirtyRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapUpdateCountdown">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLastMillis">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapDirtyRectLightmapUpdate">
            <summary>
            true if the updates included lightmap changes (widen)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapMaterial">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.msBlendTextureGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.msNormalMapNameGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.msLightmapNameGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.msCompositeMapNameGenerator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLodMorphRequired">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mNormalMapRequired">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLightMapRequired">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLightMapShadowsOnly">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCompositeMapRequired">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mTerrainNormalMap">
            <summary>
            texture storing normals for the whole terrain
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mCpuTerrainNormalMap">
            <summary>
            pending data
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLastLODCamera">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLastLODFrame">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mLightmapExtraDirtyRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mNeighbours">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDirtyGeometryRectForNeighbours">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mDirtyLightmapFromNeighboursRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mVisibilityFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mQueryFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.Terrain.mIsLoaded">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.#ctor(Axiom.Core.SceneManager)">
            <summary>
            
            </summary>
            <param name="sm"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.ConvertPosition(Axiom.Components.Terrain.Space,Axiom.Math.Vector3,Axiom.Components.Terrain.Space,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from one space to another with respect to this terrain.
            </summary>
            <param name="inSpace">The space that inPos is expressed as</param>
            <param name="inPos">The incoming position</param>
            <param name="outSpace">The space which outPos should be expressed as</param>
            <param name="outPos"> The output position to be populated</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.ConvertPosition(Axiom.Components.Terrain.Space,Axiom.Math.Vector3,Axiom.Components.Terrain.Space)">
            <summary>
            Convert a position from one space to another with respect to this terrain.
            </summary>
            <param name="inSpace"> The space that inPos is expressed as</param>
            <param name="inPos">The incoming position</param>
            <param name="outSpace">The space which outPos should be expressed as</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.ConvertDirection(Axiom.Components.Terrain.Space,Axiom.Math.Vector3,Axiom.Components.Terrain.Space,Axiom.Math.Vector3@)">
            <summary>
            Convert a direction from one space to another with respect to this terrain.
            </summary>
            <param name="inSpace">The space that inDir is expressed as</param>
            <param name="inDir">The incoming direction</param>
            <param name="outSpace">The space which outDir should be expressed as</param>
            <param name="outDir">The output direction to be populated</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.ConvertDirection(Axiom.Components.Terrain.Space,Axiom.Math.Vector3,Axiom.Components.Terrain.Space)">
            <summary>
            Convert a direction from one space to another with respect to this terrain.
            </summary>
            <param name="inSpace">The space that inDir is expressed as</param>
            <param name="inDir">The incoming direction</param>
            <param name="outSpace">The space which outDir should be expressed as</param>
            <returns>The output direction </returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Save(System.String)">
            <summary>
            Save terrain data in native form to a standalone file
            </summary>
            <param name="fileName"></param>
            <note>
            This is a fairly basic way of saving the terrain, to save to a
            file in the resource system, or to insert the terrain data into a
            shared file, use the StreamSerialiser form.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Save(Axiom.Serialization.StreamSerializer)">
            <summary>
            Save terrain data in native form to a serializing stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Prepare(System.String)">
            <summary>
            Prepare the terrain from a standalone file.
            </summary>
            <param name="fileName"></param>
            <note>
            This is safe to do in a background thread as it creates no GPU resources.
            It reads data from a native terrain data chunk. For more advanced uses, 
            such as loading from a shared file, use the StreamSerialiser form.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Prepare(Axiom.Serialization.StreamSerializer)">
            <summary>
            Prepare terrain data from saved data.
            </summary>
            <param name="stream"></param>
            <remarks>
            This is safe to do in a background thread as it creates no GPU resources.
            It reads data from a native terrain data chunk. 
            </remarks>
            <returns>true if the preparation was successful</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Prepare(Axiom.Components.Terrain.ImportData)">
            <summary>
            Prepare the terrain from some import data rather than loading from 
            native data. 
            </summary>
            <param name="importData"></param>
            <returns></returns>
            <remarks>
            This method may be called in a background thread.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Load(System.String)">
            <summary>
            Prepare and load the terrain in one simple call from a standalone file.
            </summary>
            <param name="fileName"></param>
            <note>
            This method must be called from the primary render thread. To load data
            in a background thread, use the prepare() method.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Load(Axiom.Serialization.StreamSerializer)">
            <summary>
             Prepare and load the terrain in one simple call from a standalone file.
            </summary>
            <param name="stream"></param>
            <note>
            This method must be called from the primary render thread. To load data
            in a background thread, use the prepare() method.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Load">
            <summary>
            Load the terrain based on the data already populated via prepare methods.
            </summary>
            <remarks>
            This method must be called in the main render thread. 
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Unload">
            <summary>
             Unload the terrain and free GPU resources. 
            </summary>
            <remarks>
            This method must be called in the main render thread.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Unprepare">
            <summary>
            Free CPU resources created during prepare methods.
            </summary>
            <remarks>
            This is safe to do in a background thread after calling unload().
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetHeightAtPoint(System.Int64,System.Int64)">
            <summary>
            Get the height data for a given terrain point. 
            </summary>
            <param name="x">x, y Discrete coordinates in terrain vertices, values from 0 to size-1,
            left/right bottom/top</param>
            <param name="y">x, y Discrete coordinates in terrain vertices, values from 0 to size-1,
            left/right bottom/top</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetHeightAtPoint(System.Int64,System.Int64,System.Single)">
            <summary>
            Set the height data for a given terrain point. 
            </summary>
            <note>
            this doesn't take effect until you call update()
            </note>
            <param name="x"> x, y Discrete coordinates in terrain vertices, values from 0 to size-1,
            left/right bottom/top</param>
            <param name="y"> x, y Discrete coordinates in terrain vertices, values from 0 to size-1,
            left/right bottom/top</param>
            <param name="heightVal">The new height</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetHeightAtTerrainPosition(System.Single,System.Single)">
            <summary>
            Get the height data for a given terrain position. 
            </summary>
            <param name="x">x, y Position in terrain space, values from 0 to 1 left/right bottom/top</param>
            <param name="y">x, y Position in terrain space, values from 0 to 1 left/right bottom/top</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetHeightAtWorldPosition(System.Single,System.Single,System.Single)">
            <summary>
            Get the height data for a given world position (projecting the point
            down on to the terrain).
            </summary>
            <param name="x">x, y,z Position in world space. Positions will be clamped to the edge
            of the terrain</param>
            <param name="y">x, y,z Position in world space. Positions will be clamped to the edge
            of the terrain</param>
            <param name="z">x, y,z Position in world space. Positions will be clamped to the edge
            of the terrain</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetHeightAtWorldPosition(Axiom.Math.Vector3)">
            <summary>
            Get the height data for a given world position (projecting the point
            down on to the terrain).
            </summary>
            <param name="pos">Position in world space. Positions will be clamped to the edge
            of the terrain</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetDeltaData(System.Int64,System.Int64)">
            <summary>
            Get a pointer to the delta data for a given point. 
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetHeightData(System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPoint(System.Int64,System.Int64,Axiom.Math.Vector3@)">
            <summary>
            Get a Vector3 of the world-space point on the terrain, aligned as per
            options.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outpos"></param>
            <note>
            This point is relative to Terrain.Position
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPointAlign(System.Int64,System.Int64,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="align"></param>
            <param name="outPos"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPointAlign(System.Int64,System.Int64,System.Single,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="height"></param>
            <param name="aling"></param>
            <param name="outPos"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPoint(System.Int64,System.Int64,System.Single,Axiom.Math.Vector3@)">
            <summary>
            Get a Vector3 of the world-space point on the terrain, supplying the
            height data manually (can be more optimal). 
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="height"></param>
            <param name="outPos"></param>
            <note>
            This point is relative to Terrain.Position
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainVector(Axiom.Math.Vector3,Axiom.Math.Vector3@)">
            <summary>
            Translate a vector from world space to local terrain space based on the alignment options.
            </summary>
            <param name="inVec">The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetVectorAlign(Axiom.Math.Vector3,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="invec"></param>
            <param name="align"></param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetVectorAlign(System.Single,System.Single,System.Single,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="align"></param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainVectorAlign(Axiom.Math.Vector3,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            Translate a vector from world space to local terrain space based on the alignment options.
            </summary>
            <param name="inVec">The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="align"></param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainVector(System.Single,System.Single,System.Single,Axiom.Math.Vector3@)">
            <summary>
            Translate a vector from world space to local terrain space based on the alignment options. 
            </summary>
            <param name="x">x, y, z The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="y">x, y, z The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="z">x, y, z The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainVectorAlign(System.Single,System.Single,System.Single,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            Translate a vector from world space to local terrain space based on a specified alignment.
            </summary>
            <param name="x">x, y, z The vector in world space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="y">x, y, z The vector in world space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="z">x, y, z The vector in world space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="aling"></param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetVector(System.Single,System.Single,System.Single,Axiom.Math.Vector3@)">
            <summary>
            Translate a vector into world space based on the alignment options.
            </summary>
            <param name="x">x, y, z The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="y">x, y, z The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="z">x, y, z The vector in basis space, where x/y represents the 
            terrain plane and z represents the up vector</param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetVector(Axiom.Math.Vector3,Axiom.Math.Vector3@)">
            <summary>
            Translate a vector into world space based on the alignment options.
            </summary>
            <param name="invec"></param>
            <param name="outVec"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPosition(Axiom.Math.Vector3,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="TSPos"></param>
            <param name="outWSpos"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPosition(System.Single,System.Single,System.Single,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from terrain basis space to world space. 
            </summary>
            <param name="x">x,y,z Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="y">x,y,z Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="z">x,y,z Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="outWSpos"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainPosition(Axiom.Math.Vector3,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from world space to terrain basis space. 
            </summary>
            <param name="WSpos">World space position (setup according to current alignment). </param>
            <param name="outTSpos">Terrain space output position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainPosition(System.Single,System.Single,System.Single,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from world space to terrain basis space. 
            </summary>
            <param name="x">x,y,z World space position (setup according to current alignment).</param>
            <param name="y">x,y,z World space position (setup according to current alignment).</param>
            <param name="z">x,y,z World space position (setup according to current alignment).</param>
            <param name="outTSpos">Terrain space output position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPositionAlign(Axiom.Math.Vector3,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from terrain basis space to world space based on a specified alignment. 
            </summary>
            <param name="TSpos">Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="align"></param>
            <param name="outWSpos">World space output position (setup according to alignment). </param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPositionAlign(System.Single,System.Single,System.Single,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from terrain basis space to world space based on a specified alignment. 
            </summary>
            <param name="x">x,y,z Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="y">x,y,z Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="z">x,y,z Terrain space position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
            <param name="align"></param>
            <param name="outWSpos">World space output position (setup according to alignment). </param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainPositionAlign(Axiom.Math.Vector3,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from world space to terrain basis space based on a specified alignment. 
            </summary>
            <param name="WSpos">World space position (setup according to alignment). </param>
            <param name="align"></param>
            <param name="outTSpos"> Terrain space output position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetTerrainPositionAlign(System.Single,System.Single,System.Single,Axiom.Components.Terrain.Alignment,Axiom.Math.Vector3@)">
            <summary>
            Convert a position from world space to terrain basis space based on a specified alignment. 
            </summary>
            <param name="x">x,y,z World space position (setup according to alignment). </param>
            <param name="y">x,y,z World space position (setup according to alignment). </param>
            <param name="z">x,y,z World space position (setup according to alignment). </param>
            <param name="align"></param>
            <param name="outTSpos">Terrain space output position, where (0,0) is the bottom-left of the
            terrain, and (1,1) is the top-right. The Z coordinate is in absolute
            height units.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.AddLayer">
            <summary>
            Add a new layer to this terrain.
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.AddLayer(System.Single)">
            <summary>
            Add a new layer to this terrain.
            </summary>
            <param name="worldSize">The size of the texture in this layer in world units. Default
            to zero to use the default</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.AddLayer(System.Single,System.Collections.Generic.List{System.String})">
            <summary>
            Add a new layer to this terrain.
            </summary>
            <param name="worldSize">The size of the texture in this layer in world units. Default
            to zero to use the default</param>
            <param name="textureNames">A list of textures to assign to the samplers in this
            layer. Leave blank to provide these later. </param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RemoveLayer(System.Byte)">
            <summary>
            Remove a layer from the terrain.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLayerWorldSize(System.Byte)">
            <summary>
            How large an area in world space the texture in a terrain layer covers
            before repeating.
            </summary>
            <param name="index">The layer index.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetLayerWorldSize(System.Byte,System.Single)">
            <summary>
            How large an area in world space the texture in a terrain layer covers
            before repeating.
            </summary>
            <param name="index">The layer index.</param>
            <param name="size">The world size of the texture before repeating</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLayerUVMultiplier(System.Byte)">
            <summary>
            Get the layer UV multiplier. 
            </summary>
            <remarks>
            This is derived from the texture world size. The base UVs in the 
            terrain vary from 0 to 1 and this multiplier is used (in a fixed-function 
            texture coord scaling or a shader parameter) to translate it to the
            final value.
            </remarks>
            <param name="index">The layer index.</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLayerTextureName(System.Byte,System.Byte)">
            <summary>
            Get the name of the texture bound to a given index within a given layer.
            See the LayerDeclaration for a list of sampelrs within a layer.
            </summary>
            <param name="layerIndex">The layer index.</param>
            <param name="samplerIndex"> The sampler index within a layer</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetLayerTextureName(System.Byte,System.Byte,System.String)">
            <summary>
            Set the name of the texture bound to a given index within a given layer.
            See the LayerDeclaration for a list of sampelrs within a layer.
            </summary>
            <param name="layerIndex">The layer index.</param>
            <param name="samplerIndex">The sampler index within a layer</param>
            <param name="textureName">The name of the texture to use</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Dirty">
            <summary>
            Mark the entire terrain as dirty. 
            By marking a section of the terrain as dirty, you are stating that you have
            changed the height data within this rectangle. This rectangle will be merged with
            any existing outstanding changes. To finalise the changes, you must 
            call update(), updateGeometry(), or updateDerivedData().
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Axiom.Components.Terrain.Terrain.DirtyRect(Axiom.Core.Rectangle)" -->
        <member name="M:Axiom.Components.Terrain.Terrain.DirtyCompositeMapRect(Axiom.Core.Rectangle)">
            <summary>
             Mark a region of the terrain composite map as dirty. 
            </summary>
            <param name="rect"></param>
            <remarks>
            You don't usually need to call this directly, it is inferred from 
            changing the other data on the terrain.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Update">
            <summary>
            Trigger the update process for the terrain. (default non synchronous update)
            </summary>
            <remarks>
            Updating the terrain will process any dirty sections of the terrain.
            This may affect many things:
            <ol><li>The terrain geometry</li>
            <li>The terrain error metrics which determine LOD transitions</li>
            <li>The terrain normal map, if present</li>
            <li>The terrain lighting map, if present</li>
            <li>The terrain composite map, if present</li>
            </ol>
            If threading is enabled, only item 1 (the geometry) will be updated
            synchronously, ie will be fully up to date when this method returns.
            The other elements are more expensive to compute, and will be queued
            for processing in a background thread, in the order shown above. As these
            updates complete, the effects will be shown.
            
            You can also separate the timing of updating the geometry, LOD and the lighting
            information if you want, by calling updateGeometry() and
            updateDerivedData() separately.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.Update(System.Boolean)">
            <summary>
            Trigger the update process for the terrain.
            </summary>
            <remarks>
            Updating the terrain will process any dirty sections of the terrain.
            This may affect many things:
            <ol><li>The terrain geometry</li>
            <li>The terrain error metrics which determine LOD transitions</li>
            <li>The terrain normal map, if present</li>
            <li>The terrain lighting map, if present</li>
            <li>The terrain composite map, if present</li>
            </ol>
            If threading is enabled, only item 1 (the geometry) will be updated
            synchronously, ie will be fully up to date when this method returns.
            The other elements are more expensive to compute, and will be queued
            for processing in a background thread, in the order shown above. As these
            updates complete, the effects will be shown.
            
            You can also separate the timing of updating the geometry, LOD and the lighting
            information if you want, by calling updateGeometry() and
            updateDerivedData() separately.
            </remarks>
            <param name="synchronous">synchronous If true, all updates will happen immediately and not
            in a separate thread.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateGeometry">
            <summary>
            Performs an update on the terrain geometry based on the dirty region.
            </summary>
            <remarks>
            Terrain geometry will be updated when this method returns.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateDerivedData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateDerivedData(System.Boolean)">
            <summary>
            Updates derived data for the terrain (LOD, lighting) to reflect changed height data, in a separate
            thread if threading is enabled. 
            If threading is enabled, on return from this method the derived
            data will not necessarily be updated immediately, the calculation 
            may be done in the background. Only one update will run in the background
            at once. This derived data can typically survive being out of sync for a 
            few frames which is why it is not done synchronously
            </summary>
            <param name="synchronous">If true, the update will happen immediately and not
            in a separate thread.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateDerivedData(System.Boolean,System.Byte)">
            <summary>
            Updates derived data for the terrain (LOD, lighting) to reflect changed height data, in a separate
            thread if threading is enabled. 
            If threading is enabled, on return from this method the derived
            data will not necessarily be updated immediately, the calculation 
            may be done in the background. Only one update will run in the background
            at once. This derived data can typically survive being out of sync for a 
            few frames which is why it is not done synchronously
            </summary>
            <param name="synchronous">If true, the update will happen immediately and not
            in a separate thread.</param>
            <param name="typeMask">Mask indicating the types of data we should generate</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateCompositeMap">
            <summary>
            Performs an update on the terrain composite map based on its dirty region.
            </summary>
            <remarks>
            Rather than calling this directly, call updateDerivedData, which will
            also call it after the other derived data has been updated (there is
            no point updating the composite map until lighting has been updated).
            However the blend maps may call this directly when only the blending 
            information has been updated.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateCompositeMapWithDelay">
            <summary>
            Performs an update on the terrain composite map based on its dirty region, 
            but only at a maximum frequency. 
            </summary>
            <remarks>
            Rather than calling this directly, call updateDerivedData, which will
            also call it after the other derived data has been updated (there is
            no point updating the composite map until lighting has been updated).
            However the blend maps may call this directly when only the blending 
            information has been updated.
            </remarks>
            <note>
            This method will log the request for an update, but won't do it just yet 
            unless there are no further requests in the next 'delay' seconds. This means
            you can call it all the time but only pick up changes in quiet times.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateCompositeMapWithDelay(System.Single)">
            <summary>
            Performs an update on the terrain composite map based on its dirty region, 
            but only at a maximum frequency. 
            </summary>
            <remarks>
            Rather than calling this directly, call updateDerivedData, which will
            also call it after the other derived data has been updated (there is
            no point updating the composite map until lighting has been updated).
            However the blend maps may call this directly when only the blending 
            information has been updated.
            </remarks>
            <note>
            This method will log the request for an update, but won't do it just yet 
            unless there are no further requests in the next 'delay' seconds. This means
            you can call it all the time but only pick up changes in quiet times.
            </note>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CalculateHeightDeltas(Axiom.Core.Rectangle)">
            <summary>
            Calculate (or recalculate) the delta values of heights between a vertex
            in its recorded position, and the place it will end up in the LOD
            in which it is removed. 
            </summary>
            <param name="rect">Rectangle describing the area in which heights have altered </param>
            <returns>A Rectangle describing the area which was updated (may be wider
            than the input rectangle)</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.FinalizeHeightDeltas(Axiom.Core.Rectangle,System.Boolean)">
            <summary>
            Finalise the height deltas. 
            Calculated height deltas are kept in a separate calculation field to make
            them safe to perform in a background thread. This call promotes those
            calculations to the runtime values, and must be called in the main thread.
            </summary>
            <param name="rect">Rectangle describing the area to finalise </param>
            <param name="cpuData">When updating vertex data, update the CPU copy (background)</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetPointFromSelfOrNeighbour(System.Int64,System.Int64,Axiom.Math.Vector3@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outpos"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CalculateNormals(Axiom.Core.Rectangle,Axiom.Core.Rectangle@)">
            <summary>
            Calculate (or recalculate) the normals on the terrain
            </summary>
            <param name="rect">Rectangle describing the area of heights that were changed</param>
            <param name="outFinalRect"> Output rectangle describing the area updated</param>
            <returns>PixelBox full of normals (caller responsible for deletion)</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.FinalizeNormals(Axiom.Core.Rectangle,Axiom.Media.PixelBox)">
            <summary>
            Finalise the normals. 
            Calculated normals are kept in a separate calculation area to make
            them safe to perform in a background thread. This call promotes those
            calculations to the runtime values, and must be called in the main thread.
            </summary>
            <param name="rect">Rectangle describing the area to finalize </param>
            <param name="normalsBox">PixelBox full of normals</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CalculateLightMap(Axiom.Core.Rectangle,Axiom.Core.Rectangle,Axiom.Core.Rectangle@)">
            <summary>
             Calculate (or recalculate) the terrain lightmap
            </summary>
            <param name="rect">Rectangle describing the area of heights that were changed</param>
            <param name="extraTargetRect">extraTargetRect Rectangle describing a target area of the terrain that
            needs to be calculated additionally (e.g. from a neighbour)
            </param>
            <param name="outFinalRect">Output rectangle describing the area updated in the lightmap</param>
            <returns> PixelBox full of lighting data (caller responsible for deletion)</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.FinalizeLightMap(Axiom.Core.Rectangle,Axiom.Media.PixelBox)">
            <summary>
            Finalise the lightmap. 
            Calculating lightmaps is kept in a separate calculation area to make
            it safe to perform in a background thread. This call promotes those
            calculations to the runtime values, and must be called in the main thread.
            </summary>
            <param name="rect">Rectangle describing the area to finalize </param>
            <param name="lightmapBox">PixelBox full of normals</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetResolutionAtLod(System.UInt16)">
            <summary>
            Gets the resolution of the entire terrain (down one edge) at a 
            given LOD level.
            </summary>
            <param name="lodLevel"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RRayIntersects(Axiom.Math.Ray)">
            <summary>
            Test for intersection of a given ray with the terrain. If the ray hits
            the terrain, the point of intersection is returned.
            </summary>
            <param name="ray">The ray to test for intersection</param>
            <returns>A pair which contains whether the ray hit the terrain and, if so, where.</returns>
            <remarks>
            This can be called from any thread as long as no parallel write to
            the heightmap data occurs.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RayIntersects(Axiom.Math.Ray)">
            <summary>
            
            </summary>
            <param name="ray"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RayIntersects(Axiom.Math.Ray,System.Boolean,System.Single)">
            <summary>
            
            </summary>
            <param name="ray"></param>
            <param name="cascadeToNeighbours"></param>
            <param name="distanceLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLayerBlendMap(System.Byte)">
            <summary>
            Retrieve the layer blending map for a given layer, which may
            be used to edit the blending information for that layer.
            </summary>
            <note>
            You can only do this after the terrain has been loaded. You may 
            edit the content of the blend layer in another thread, but you
            may only upload it in the main render thread.
            </note>
            <param name="layerIndex">The layer index, which should be 1 or higher (since 
            the bottom layer has no blending).</param>
            <returns>Pointer to the TerrainLayerBlendMap requested. The caller must
            not delete this instance, use freeTemporaryResources if you want
            to save the memory after completing your editing.</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetBlendTextureIndex(System.Byte)">
            <summary>
             Get the index of the blend texture that a given layer uses.
            </summary>
            <param name="layerIndex">The layer index, must be >= 1 and less than the number
            of layers</param>
            <returns>The index of the shared blend texture</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetBlendTextureCount">
            <summary>
            Get the number of blend textures in use
            </summary>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetBlendTextureCount(System.Byte)">
            <summary>
            Get the number of blend textures needed for a given number of layers
            </summary>
            <param name="numLayers"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetBlendTextureName(System.Byte)">
            <summary>
            Get the name of the packed blend texture at a specific index.
            </summary>
            <param name="textureIndex">This is the blend texture index, not the layer index
            (multiple layers will share a blend texture)</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetGlobalColorMapEnabled(System.Boolean)">
            <summary>
             Set whether a global colour map is enabled. 
            </summary>
            <remarks>
            A global colour map can add variation to your terrain and reduce the 
            perceived tiling effect you might get in areas of continuous lighting
            and the same texture. 
            The global colour map is only used when the material generator chooses
            to use it.
            </remarks>
            <note>
            You must only call this from the main render thread
            </note>
            <param name="enable">Whether the global colour map is enabled or not</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetGlobalColorMapEnabled(System.Boolean,System.UInt16)">
            <summary>
             Set whether a global colour map is enabled. 
            </summary>
            <remarks>
            A global colour map can add variation to your terrain and reduce the 
            perceived tiling effect you might get in areas of continuous lighting
            and the same texture. 
            The global colour map is only used when the material generator chooses
            to use it.
            </remarks>
            <note>
            You must only call this from the main render thread
            </note>
            <param name="enable">Whether the global colour map is enabled or not</param>
            <param name="size">the resolution of the color map. A value of zero means 'no change'
            and the default is set in TerrainGlobalOptions.</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.WidenRectByVector(Axiom.Math.Vector3,Axiom.Core.Rectangle,System.Single,System.Single,Axiom.Core.Rectangle@)">
            <summary>
            
            </summary>
            <param name="vec"></param>
            <param name="inRect"></param>
            <param name="minHeight"></param>
            <param name="maxHeight"></param>
            <param name="outRect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.WidenRectByVector(Axiom.Math.Vector3,Axiom.Core.Rectangle,Axiom.Core.Rectangle@)">
            <summary>
            Widen a rectangular area of terrain to take into account an extrusion vector.
            </summary>
            <param name="vec"> A vector in world space</param>
            <param name="inRec">Input rectangle</param>
            <param name="outRect">Output rectangle</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.FreeTemporaryResources">
            <summary>
            Free as many resources as possible for optimal run-time memory use.
            </summary>
            <remarks>
            This class keeps some temporary storage around in order to make
            certain actions (such as editing) possible more quickly. Calling this
            method will cause as many of those resources as possible to be
            freed. You might want to do this for example when you are finished
            editing a particular terrain and want to have optimal runtime
            efficiency.
            </remarks>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLayerBlendTexture(System.Byte)">
            <summary>
            Get a blend texture with a given index.
            </summary>
            <param name="index">The blend texture index (note: not layer index; derive
            the texture index from getLayerBlendTextureIndex)</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLayerBlendTextureIndex(System.Byte)">
            <summary>
            Get the texture index and colour channel of the blend information for 
            a given layer. 
            </summary>
            <param name="layerIndex">The index of the layer (1 or higher, layer 0 has no blend data)</param>
            <returns>A pair in which the first value is the texture index, and the 
            second value is the colour channel (RGBA)</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetLightMapRequired(System.Boolean)">
            <summary>
            Request internal implementation options for the terrain material to use, 
            in this case a terrain-wide normal map. 
            The TerrainMaterialGenerator should call this method to specify the 
            options it would like to use when creating a material. Not all the data
            is guaranteed to be up to date on return from this method - for example some
            maps may be generated in the background. However, on return from this method
            all the features that are requested will be referenceable by materials, the
            data may just take a few frames to be fully populated.
            </summary>
            <param name="lightMap">Whether a terrain-wide lightmap including precalculated 
            lighting is required (light direction in TerrainGlobalOptions)</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetLightMapRequired(System.Boolean,System.Boolean)">
            <summary>
            Request internal implementation options for the terrain material to use, 
            in this case a terrain-wide normal map. 
            The TerrainMaterialGenerator should call this method to specify the 
            options it would like to use when creating a material. Not all the data
            is guaranteed to be up to date on return from this method - for example some
            maps may be generated in the background. However, on return from this method
            all the features that are requested will be referenceable by materials, the
            data may just take a few frames to be fully populated.
            </summary>
            <param name="lightMap">Whether a terrain-wide lightmap including precalculated 
            lighting is required (light direction in TerrainGlobalOptions)</param>
            <param name="shadowsOnly">If true, the lightmap contains only shadows, 
            no directional lighting intensity</param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLODLevelWhenVertexEliminated(System.Int64,System.Int64)">
            <summary>
            Utility method, get the first LOD Level at which this vertex is no longer included
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetLODLevelWhenVertexEliminated(System.Int64)">
            <summary>
            Utility method, get the first LOD Level at which this vertex is no longer included
            </summary>
            <param name="rowOrColulmn"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.FreeCPUResources">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CheckQuadIntersection(System.Int32,System.Int32,Axiom.Math.Ray)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="ray"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.FreeGPUResources">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.DetermineLodLevels">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.DistributeVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateBaseScale">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CreateGPUBlendTextures">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CreateLayerBlendMaps">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CreateOrDestroyGPUNormalMap">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.ConvertSpace(Axiom.Components.Terrain.Space,Axiom.Math.Vector3,Axiom.Components.Terrain.Space,Axiom.Math.Vector3@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="inSpace"></param>
            <param name="inVec"></param>
            <param name="outSpace"></param>
            <param name="outVec"></param>
            <param name="translation"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CreateOrDestroyGPUColorMap">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CreateOrDestroyGPULightmap">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CreateOrDestroyGPUCompositeMap">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.WaitForDerivedProcesses">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.convertWorldToTerrainAxes(Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="inVec"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.convertTerrainToWorldAxes(Axiom.Math.Vector3)">
            <summary>
            
            </summary>
            <param name="inVec"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CheckLayers(System.Boolean)">
            <summary>
            
            </summary>
            <param name="includeGpuResources"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CheckDeclaration">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetBlendTextureFormat(System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="textureIndex"></param>
            <param name="numLayers"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CopyGlobalOptions">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.DeriveUVMultipliers">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.IntPtrToArray(System.IntPtr,System.Byte[]@)">
            <summary>
            Copys an intptr pointer to an byte array.
            </summary>
            <param name="srcPtr"></param>
            <param name="dstArray"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.UpdateDerivedDataImpl(Axiom.Core.Rectangle,Axiom.Core.Rectangle,System.Boolean,System.Byte)">
            <summary>
            
            </summary>
            <param name="rect"></param>
            <param name="synchronous"></param>
            <param name="typeMask"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.CalculateCurrentLod(Axiom.Core.Viewport)">
            <summary>
            
            </summary>
            <param name="vp"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.AddQueryFlag(System.UInt32)">
            <summary>
            
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RemoveQueryFlags(System.UInt32)">
            <summary>
            
            </summary>
            <param name="flags"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetNeighbour(Axiom.Components.Terrain.NeighbourIndex)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetNeighbour(Axiom.Components.Terrain.NeighbourIndex,Axiom.Components.Terrain.Terrain)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="neighbour"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.SetNeighbour(Axiom.Components.Terrain.NeighbourIndex,Axiom.Components.Terrain.Terrain,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="neighbour"></param>
            <param name="recalculate"></param>
            <param name="notifyOther"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetOppositeNeighbour(Axiom.Components.Terrain.NeighbourIndex)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.NotifyNeighbours">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.NeighbourModified(Axiom.Components.Terrain.NeighbourIndex,Axiom.Core.Rectangle,Axiom.Core.Rectangle)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="edgeRect"></param>
            <param name="shadowRect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RaySelectNeighbour(Axiom.Math.Ray)">
            <summary>
            
            </summary>
            <param name="ray"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.RaySelectNeighbour(Axiom.Math.Ray,System.Single)">
            <summary>
            
            </summary>
            <param name="ray"></param>
            <param name="distanceLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.DumpTextures(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="prefix"></param>
            <param name="suffix"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetEdgeRect(Axiom.Components.Terrain.NeighbourIndex,System.Int64,Axiom.Core.Rectangle@)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="range"></param>
            <param name="outRect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetNeighbourEdgeRect(Axiom.Components.Terrain.NeighbourIndex,Axiom.Core.Rectangle,Axiom.Core.Rectangle@)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="range"></param>
            <param name="outRect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetNeighbourPoint(Axiom.Components.Terrain.NeighbourIndex,System.Int64,System.Int64,System.Int64@,System.Int64@)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outX"></param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.GetNeighbourPointOverflow(System.Int64,System.Int64,Axiom.Components.Terrain.NeighbourIndex@,System.Int64@,System.Int64@)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="outIndex"></param>
            <param name="outX"></param>
            <param name="outY"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.IsPowerOfTwo(System.UInt64)">
            <summary>
            checks if the given value is power of two.
            </summary>
            <param name="x">the value to check</param>
            <returns>true if the given value is power of two</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.WriteLayerDeclaration(Axiom.Components.Terrain.TerrainLayerDeclaration,Axiom.Serialization.StreamSerializer@)">
            <summary>
            
            </summary>
            <param name="decl"></param>
            <param name="stream"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.WriteLayerInstanceList(System.Collections.Generic.List{Axiom.Components.Terrain.LayerInstance},Axiom.Serialization.StreamSerializer@)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <param name="stream"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.Terrain.ReadLayerDeclaration(Axiom.Serialization.StreamSerializer@,Axiom.Components.Terrain.TerrainLayerDeclaration@)">
            <summary>
            
            </summary>
            <param name="stream"></param>
            <param name="targetDecl"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.IsDerivedDataUpdateInProgress">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.WorldAABB">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.ResourceGroup">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.IsModified">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.IsLoaded">
            <summary>
            Return whether the terrain is loaded. 
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.VisibilityFlags">
            <summary>
            Get's or set's the visbility flags that terrains will be rendered with
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.QueryFlags">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.SceneManager">
            <summary>
            Get's the scenemanager of the terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.DeltaData">
            <summary>
            Get a pointer to all the delta data for this terrain.
            </summary>
            <remarks>
            The delta data is a measure at a given vertex of by how much vertically
            a vertex will have to move to reach the point at which it will be
            removed in the next lower LOD.
            </remarks>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.LayerBlendMapSize">
            <summary>
            Get the requested size of the blend maps used to blend between layers
            for this terrain. 
            Note that where hardware limits this, the actual blend maps may be lower
            resolution. This option is derived from TerrainGlobalOptions when the
            terrain is created.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.AABB">
            <summary>
            Get'S the AABB (local coords) of the entire terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.Size">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.RootSceneNode">
            <summary>
            Get the root scene node for the terrain (internal use only)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.Alignment">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.MinBatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.MaxBatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.WorldSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.SkirtSize">
            <summary>
            The default size of 'skirts' used to hide terrain cracks
            (default 10, set for new Terrain using TerrainGlobalOptions)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.MinHeight">
            <summary>
            Get's the minimum height of the terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.MaxHeight">
            <summary>
            Get's the maximum height of the terrain.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.BoundingRadius">
            <summary>
            Get's the bounding radius of the entire terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.Material">
            <summary>
            Get's the material being used for the terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.CompositeMapMaterial">
            <summary>
            Get's the material being used for the terrain composite map
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.MaterialName">
            <summary>
            Get's the name of the material being used for the terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.HeightData">
            <summary>
            Get a pointer to all the height data for this terrain.
            </summary>
            <remarks>
            The height data is in world coordinates, relative to the position 
            of the terrain.
            </remarks>
            <returns></returns>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.IsMorphRequired">
            <summary>
            Request internal implementation options for the terrain material to use, 
            in this case vertex morphing information. 
            The TerrainMaterialGenerator should call this method to specify the 
            options it would like to use when creating a material. Not all the data
            is guaranteed to be up to date on return from this method - for example som
            maps may be generated in the background. However, on return from this method
            all the features that are requested will be referenceable by materials, the
            data may just take a few frames to be fully populated.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.NormalMapRequired">
            <summary>
            Request internal implementation options for the terrain material to use, 
            in this case a terrain-wide normal map. 
            The TerrainMaterialGenerator should call this method to specify the 
            options it would like to use when creating a material. Not all the data
            is guaranteed to be up to date on return from this method - for example some
            maps may be generated in the background. However, on return from this method
            all the features that are requested will be referenceable by materials, the
            data may just take a few frames to be fully populated.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.Position">
            <summary>
            Get's or set's the world position of the terrain centre
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.CompositeMapRequired">
            <summary>
            Request internal implementation options for the terrain material to use, 
            in this case a terrain-wide composite map. 
            The TerrainMaterialGenerator should call this method to specify the 
            options it would like to use when creating a material. Not all the data
            is guaranteed to be up to date on return from this method - for example some
            maps may be generated in the background. However, on return from this method
            all the features that are requested will be referenceable by materials, the
            data may just take a few frames to be fully populated.
            ------------------------------------------------------
            compositeMap Whether a terrain-wide composite map is needed. A composite
            map is a texture with all of the blending and lighting baked in, such that
            at distance this texture can be used as an approximation of the multi-layer
            blended material. It is actually up to the material generator to render this
            composite map, because obviously precisely what it looks like depends on what
            the main material looks like. For this reason, the composite map is one piece
            of derived terrain data that is always calculated in the render thread, and
            usually on the GPU. It is expected that if this option is requested, 
            the material generator will use it to construct distant LOD techniques.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.GlobalColorMapEnabled">
            <summary>
            Get's whether a global color map is enabled on this terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.LightMap">
            <summary>
            Get access to the lightmap, if enabled (as requested by the material generator)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.LightMapSize">
            <summary>
            Get the requested size of lightmap for this terrain. 
            Note that where hardware limits this, the actual lightmap may be lower
            resolution. This option is derived from TerrainGlobalOptions when the
            terrain is created.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.GlobalColorMap">
            <summary>
            Get's access to the global colour map, if enabled
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.GlobalColorMapSize">
            <summary>
             Get's the size of the global colour map (if used)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.LayerDeclaration">
            <summary>
            Get's the declaration which describes the layers in this terrain.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.TerrainNormalMap">
            <summary>
            Get's the (global) normal map texture
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.CompositeMap">
            <summary>
            Get access to the composite map, if enabled (as requested by the material generator)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.QuadTree">
            <summary>
            Get's the top level of the quad tree which is used to divide up the terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.CompositeMapSize">
            <summary>
            Get the requested size of composite map for this terrain. 
            Note that where hardware limits this, the actual texture may be lower
            resolution. This option is derived from TerrainGlobalOptions when the
            terrain is created.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.LayerCount">
            <summary>
            Get's the number of layers in this terrain.
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.NumLodLevels">
            <summary>
            Get the total number of LOD levels in the terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.LodLevelsPerLeafCount">
            <summary>
            Get the number of LOD levels in a leaf of the terrain quadtree
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.RenderQueueGroupID">
            <summary>
            Get's or set's the render queue group that this terrain will be rendered into
            </summary>
            <remarks>The default is specified in TerrainGlobalOptions</remarks>
        </member>
        <member name="P:Axiom.Components.Terrain.Terrain.MaxLayers">
            <summary>
            Get the maximum number of layers supported with the current options. 
            </summary>
            <note>When you change the options requested, this value can change. </note>
        </member>
        <member name="T:Axiom.Components.Terrain.LodLevel">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.BatchSize">
            <summary>
            Number of vertices rendered down one side (not including skirts)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.CpuIndexData">
            <summary>
            index data referencing the main vertex data but in CPU buffers (built in background)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.GpuIndexData">
            <summary>
            "Real" index data on the gpu
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.MaxHeightDelta">
            <summary>
            Maximum delta height between this and the next lower lod
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.CalcMaxHeightDelta">
            <summary>
            Temp calc area for max height delta
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.LastTranistionDist">
            <summary>
            The most recently calculated transition distance
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.LodLevel.LastCFactor">
            <summary>
            The cFactor value used to calculate transitionDist
            </summary>
        </member>
        <member name="T:Axiom.Components.Terrain.VertexDataRecord">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.CpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.GpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.Resolution">
            <summary>
            resolution of the data compared to the base terrain data (NOT number of vertices!)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.Size">
            <summary>
            size of the data along one edge
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.TreeLevels">
            <summary>
            Number of quadtree levels (including this one) this data applies to
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.NumSkirtRowsCols">
            <summary>
            Number of rows and columns of skirts
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.SkirtRowColSkip">
            <summary>
            The number of rows / cols to skip in between skirts
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.VertexDataRecord.IsGpuVertexDataDirty">
            <summary>
            Is the GPU vertex data out of date?
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.VertexDataRecord.#ctor(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            
            </summary>
            <param name="res"></param>
            <param name="sz"></param>
            <param name="lvls"></param>
        </member>
        <member name="T:Axiom.Components.Terrain.TerrainQuadTreeNode">
            <summary>
            A node in a quad tree used to store a patch of terrain.
            </summary>
            <remarks>
            <b>Algorithm overview:</b>
            Our goal is to perform traditional chunked LOD with geomorphing. But, 
            instead of just dividing the terrain into tiles, we will divide them into
            a hierarchy of tiles, a quadtree, where any level of the quadtree can 
            be a rendered tile (to the exclusion of its children). The idea is to 
            collect together children into a larger batch with their siblings as LOD 
            decreases, to improve performance.
            
            The minBatchSize and maxBatchSize parameters on Terrain a key to 
            defining this behaviour. Both values are expressed in vertices down one axis.
            maxBatchSize determines the number of tiles on one side of the terrain,
            which is numTiles = (terrainSize-1) / (maxBatchSize-1). This in turn determines the depth
            of the quad tree, which is sqrt(numTiles). The minBatchSize determines
            the 'floor' of how low the number of vertices can go in a tile before it
            has to be grouped together with its siblings to drop any lower. We also do not group 
            a tile with its siblings unless all of them are at this minimum batch size, 
            rather than trying to group them when they all end up on the same 'middle' LOD;
            this is for several reasons; firstly, tiles hitting the same 'middle' LOD is
            less likely and more transient if they have different levels of 'roughness',
            and secondly since we're sharing a vertex / index pool between all tiles, 
            only grouping at the min level means that the number of combinations of 
            buffer sizes for any one tile is greatly simplified, making it easier to 
            pool data. To be more specific, any tile / quadtree node can only have
            log2(maxBatchSize-1) - log2(minBatchSize-1) + 1 LOD levels (and if you set them 
            to the same value, LOD can only change by going up/down the quadtree).
            The numbers of vertices / indices in each of these levels is constant for
            the same (relative) LOD index no matter where you are in the tree, therefore
            buffers can potentially be reused more easily.
            </remarks>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.POSITION_BUFFER">
            <summary>
            Buffer binding used for holding positions.
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.DELTA_BUFFER">
            <summary>
            Buffer binding used for holding delta values
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mLodLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mTerrain">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mParent">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mChildren">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mOffsetX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mOffsetY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mBoundaryX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mBoundaryY">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mBaseLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mQuadrant">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mLocalCentre">
            <summary>
            relative to terrain centre
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mAABB">
            <summary>
            relative to mLocalCentre
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mBoundingRadius">
            <summary>
            relative to mLocalCentre
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mCurrentLod">
            <summary>
            -1 = none (do not render)
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mLodTransition">
            <summary>
            // 0-1 transition to lower LOD
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mChildWithMaxHeightDelta">
            <summary>
            The child with the largest height delta 
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mSelfOrChildRendered">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mMaterialLodIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mNodeWithVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="F:Axiom.Components.Terrain.TerrainQuadTreeNode.mVertexDataRecord">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.#ctor(Axiom.Components.Terrain.Terrain,Axiom.Components.Terrain.TerrainQuadTreeNode,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Default constructor.
            </summary>
            <param name="terrain">The ultimate parent terrain</param>
            <param name="parent">ptional parent node (in which case xoff, yoff are 0 and size must be entire terrain)</param>
            <param name="xOff">Offsets from the start of the terrain data in 2D</param>
            <param name="yOff">Offsets from the start of the terrain data in 2D</param>
            <param name="size">The size of the node in vertices at the highest LOD</param>
            <param name="lod">The base LOD level</param>
            <param name="depth">The depth that this node is at in the tree (or convenience)</param>
            <param name="quadrant">The index of the quadrant (0, 1, 2, 3)</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.GetChild(System.UInt16)">
            <summary>
            Get child node
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.Prepare">
            <summary>
            Prepare node and children (perform CPU tasks, may be background thread)
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.Load">
            <summary>
             Load node and children (perform GPU tasks, will be render thread)
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.Unload">
            <summary>
            Unload node and children (perform GPU tasks, will be render thread)
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.Unprepare">
            <summary>
            Unprepare node and children (perform CPU tasks, may be background thread)
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.GetLodLevel(System.UInt16)">
            <summary>
            Get the LodLevel information for a given lod.
            </summary>
            <param name="lod">
            The lod level index relative to this classes own list; if you
            want to use a global lod level, subtract getBaseLod() first. Higher
            LOD levels are lower detail.
            </param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.PreDeltaCalculation(Axiom.Core.Rectangle)">
            <summary>
             Notify the node (and children) that deltas are going to be calculated for a given range.
            </summary>
            <param name="rect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.NotifyDelta(System.UInt16,System.UInt16,System.UInt16,System.Single)">
            <summary>
            Notify the node (and children) of a height delta value.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="lod"></param>
            <param name="delta"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.PostDeltaCalculation(Axiom.Core.Rectangle)">
            <summary>
            Notify the node (and children) that deltas are going to be calculated for a given range.
            </summary>
            <param name="rect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.FinaliseDeltaValues(Axiom.Core.Rectangle)">
            <summary>
            Promote the delta values calculated to the runtime ones (this must
            be called in the main thread). 
            </summary>
            <param name="rect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.AssignVertexData(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Assign vertex data to the tree, from a depth and at a given resolution.
            </summary>
            <param name="treeDeptStart">The first depth of tree that should use this data, owns the data</param>
            <param name="treeDepthEnd">The end of the depth that should use this data (exclusive)</param>
            <param name="resolution">The resolution of the data to use (compared to full terrain)</param>
            <param name="sz">The size of the data along one edge</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.UseAncestorVertexData(Axiom.Components.Terrain.TerrainQuadTreeNode,System.Int32,System.Int32)">
            <summary>
            Tell a node that it should use an anscestor's vertex data.
            </summary>
            <param name="owner"></param>
            <param name="treeDepthEnd">The end of the depth that should use this data (exclusive)</param>
            <param name="resolution">The resolution of the data to use</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.UpdateVertexData(System.Boolean,System.Boolean,Axiom.Core.Rectangle,System.Boolean)">
            <summary>
            Tell the node to update its vertex data for a given region. 
            </summary>
            <param name="positions"></param>
            <param name="deltas"></param>
            <param name="rect"></param>
            <param name="cpuData"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.MergeIntoBounds(System.Int64,System.Int64,Axiom.Math.Vector3)">
            <summary>
            Merge a point (relative to terrain node) into the local bounds, 
            and that of children if applicable.
            </summary>
            <param name="x">The point on the terrain to which this position corresponds 
            (affects which nodes update their bounds)</param>
            <param name="y">The point on the terrain to which this position corresponds 
            (affects which nodes update their bounds)</param>
            <param name="pos">The position relative to the terrain centre</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.ResetBounds(Axiom.Core.Rectangle)">
            <summary>
            Reset the bounds of this node and all its children for the region given.
            </summary>
            <param name="rect">The region for which bounds should be reset, in top-level terrain coords</param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.RectContainsNode(Axiom.Core.Rectangle)">
            <summary>
            Returns true if the given rectangle completely contains the terrain area that
            this node references.
            </summary>
            <param name="rect">The region in top-level terrain coords</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.RectIntersectsNode(Axiom.Core.Rectangle)">
            <summary>
             Returns true if the given rectangle overlaps the terrain area that
             this node references.
            </summary>
            <param name="rect">The region in top-level terrain coords</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.PointIntersectsNode(System.Int64,System.Int64)">
            <summary>
            Returns true if the given point is in the terrain area that
            this node references.
            </summary>
            <param name="x">The point in top-level terrain coords</param>
            <param name="y">The point in top-level terrain coords</param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CalculateCurrentLod(Axiom.Core.Camera,System.Single)">
            <summary>
            Calculate appropriate LOD for this node and children
            </summary>
            <param name="cam">The camera to be used (this should already be the LOD camera)</param>
            <param name="cFactor">The cFactor which incorporates the viewport size, max pixel error and lod bias</param>
            <returns>true if this node or any of its children were selected for rendering</returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.UpdateVertexBuffer(Axiom.Graphics.HardwareVertexBuffer,Axiom.Graphics.HardwareVertexBuffer,Axiom.Core.Rectangle)">
            <summary>
            
            </summary>
            <param name="posBuff"></param>
            <param name="deltaBuf"></param>
            <param name="rect"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CreateCpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CreateCpuIndexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.DestroyCpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.DestroyCpuIndexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CreateGpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.DestroyGpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.UpdateGpuVertexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CreateGpuIndexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.DestroyGpuIndexData">
            <summary>
            
            </summary>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CreateTriangleStripBuffer(System.UInt16,Axiom.Graphics.IndexData)">
            <summary>
            
            </summary>
            <param name="batchSize"></param>
            <param name="destData"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.CalcSkirtVertexIndex(System.UInt16,System.Boolean)">
            <summary>
            
            </summary>
            <param name="mainIndex"></param>
            <param name="isCol"></param>
            <returns></returns>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.UpdateRenderQueue(Axiom.Graphics.RenderQueue)">
            <summary>
            
            </summary>
            <param name="queue"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.VisitRenderables(System.Boolean)">
            <summary>
            
            </summary>
            <param name="debugRenderables"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.GetWorldTransforms(Axiom.Math.Matrix4[])">
            <summary>
            
            </summary>
            <param name="xform"></param>
        </member>
        <member name="M:Axiom.Components.Terrain.TerrainQuadTreeNode.GetSquaredViewDepth(Axiom.Core.Camera)">
            <summary>
            
            </summary>
            <param name="cam"></param>
            <returns></returns>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.VertextDataRecord">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.XOffeset">
            <summary>
            Get the horizontal offset into the main terrain data of this node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.YOffset">
            <summary>
            Get the vertical offset into the main terrain data of this node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.BaseLod">
            <summary>
            Get the base LOD level this node starts at (the highest LOD it handles)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.LodCount">
            <summary>
            Get the number of LOD levels this node can represent itself (only > 1 for leaf nodes)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.Terrain">
            <summary>
            Get ultimate parent terrain
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.Parent">
            <summary>
            Get parent node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.IsLeaf">
            <summary>
            Is this a leaf node (no children)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.AABB">
            <summary>
            Get the AABB (local coords) of this node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.BoundingRadius">
            <summary>
            Get the bounding radius of this node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.MinHeight">
            <summary>
            Get the minimum height of the node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.MaxHeight">
            <summary>
            Get the maximum height of the node
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.CurentLod">
            <summary>
            Get the current LOD index (only valid after calculateCurrentLod)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.IsRenderedAtCurrentLod">
            <summary>
            Returns whether this node is rendering itself at the current LOD level
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.IsSelfOrChildrenRenderedAtCurrentLod">
            <summary>
            Returns whether this node or its children are being rendered at the current LOD level
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.LodTransition">
            <summary>
            Get the transition state between the current LOD and the next lower one (only valid after calculateCurrentLod)
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.Material">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.Technique">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.RenderOperation">
            <summary>
            
            </summary>
            <param name="op"></param>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.CastsShadows">
            <summary>
            
            </summary>
        </member>
        <member name="P:Axiom.Components.Terrain.TerrainQuadTreeNode.TerrainRendable.Material">
            <summary>
            
            </summary>
        </member>
    </members>
</doc>
